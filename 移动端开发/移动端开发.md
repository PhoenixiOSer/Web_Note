# 移动端开发

## 1.移动端基础

### 1.1 浏览器现状
国内浏览器都是根据 Webkit修改过来的内核，国内尚无自主研发的内核。所以兼容主流浏览器只需要处理 webkit 内核浏览器即可

### 1.2 手机屏幕现状

手机屏幕目前碎片化越来越严重，作为开发者我们无需关注这些分辨率，因为我们常用的尺寸单位是px

### 1.3 常见移动端屏幕尺寸

可以自行在 https://material.io/devices 访问查看。

### 1.4 移动端调试方法

- Chrome DevTools(开发推荐)
- 搭建本地web服务器访问
- 使用外网服务器，直接ip或者域名访问



## 2.视口

视口（viewport）就是浏览器显示页面内容的屏幕区域，视口可以分为布局视口、视觉视口和理想视口（常用）。


## 2.1 布局视口（layout viewport）

- 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早起的PC端页面在手机上显示的问题
- iOS，Android 基本将这个视口分辨率设置为 980px ，所以pc上的网页早起大多能在手机上呈现，但元素看上去很小，一般需要通过手动缩放网页查看

## 2.2 视觉视口（visual viewport）

- 字面意思，它是用户正在看到的网站区域，注意：是网站的区域
- 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度


## 2.3 理想视口（ideal viewport）

- 为了是网站在移动端有理想的浏览和阅读宽度而设定
- 理想视口，对设备来讲，是理想的视口尺寸
- 需要手动添写 meta 视口标签通知浏览器操作
- meta 视口标签主要目的：布局视口的宽度应该和理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 


## 2.5 meta 视口标签

```
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0 ,maximum-scale=1.0,minimum-scale=1.0">
```

| 属性          | 解释说明                                              |
| ------------- | ----------------------------------------------------- |
| width         | 宽度设置的是viewport 宽度，可以设置device-width特殊值 |
| initial-scale | 初始缩放比，大于0的数字                               |
| maximum-scale | 最大缩放比，大于0的数字                               |
| minimum-scale | 最小缩放比，大于0的数字                               |
| user-scalable | 用户是否可以缩放，yes 或者 no（1或0）                 |

## 2.6 标准的viewport

- 视口宽度和设备保持一致
- 视口默认缩放比例1.0
- 不允许用户自行缩放
- 最大、最小允许缩放比例为1.0

# 3.二倍图

## 3.1 物理像素和物理像素比

-  物理像素点指定是屏幕显示的最小颗粒，是物理真实存在的。这个手机厂商在出厂时就设置好了
-  我们开发时候的1px不是一定等于1个物理像素
-  PC 端页面 1个px 等于1个物理像素，但移动端不尽相同
-  一个px 的能显示的物理像素点的个数，成为物理像素比或屏幕像素比

## 3.2 多倍图
- 对于一张50*50的图片来说，在手机Retina屏中打开，按照刚才的物理像素比会放大倍速，这样会造成图片模糊
- 在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题
- 通常使用二倍图，但还存在3倍、4倍图，按实际开发要求来设置
- 背景图片注意缩放问题

## 3.3 背景缩放（background-size）

background-size 属性规定背景图片的尺寸

```
background-size: 背景图片宽度 背景图片的高度;
```

- 单位： 可以是 长度| 百分比（相对父元素） |cover|contain
- cover 会把背景图像扩展至足够大，让背景图片完全覆盖背景区域（可能部分图片显示不全）
- contain把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域（宽或高铺满时不再拉伸，可能背景区域存在空白）

## 4. 移动端开发选择

### 4.1 移动端主流方案

1. 单独制作移动端页面（主流）
2. 响应式页面兼容移动端（根据屏幕大小自动适配展示，制作麻烦对兼容性要求高）


## 5 移动端技术解决方案

### 5.1 移动端浏览器

移动端浏览器以 webkit 内核为准，因此我们就考虑 webkit 的兼容性问题，可以放心使用H5标签和C3样式。

### 5.2 CSS 初始化（normalize.css）

移动端的 CSS初始化推荐使用normalize.css/

- normalize.css：保护有价值的默认值
- normalize.css：修复了浏览器的bug
- normalize.css：模块化
- normalize.css：拥有详细的文档

官网地址： http://necolas.github.io/normalize.css


### 5.3 CSS3 盒子模型 box-sizing

- 传统的模式的宽度计算： 盒子宽度 = CSS中设置的 width + border + padding
- CSS3 盒子模型： 盒子的宽度 = CSS 中设置的宽度（包含了border + padding）
```
// 传统：
box-sizing:content-box;
// css3
box-sizing:border-box;
```

传统 or CSS3 盒子模型？

- 移动端可以全部选择 CSS3 盒子模型
- PC端如果完全需要兼容使用传统模式，不考虑兼容可以选择 CSS3 盒子模型

### 5.4 特殊样式

```
box-sizing: border-box;
-webkit-box-sizing:border-box
// 点击高亮效果清除，设置为 transparent 透明色
-webkit-tap-highlight-color:transparent;
// 在移动端浏览器默认外观，在ios上要去除默认样式后自定义样式才有效
-webkit-apperance:none

// 禁用长按页面时弹出的菜单
image,a{-webkit-touch-callout:none;}

```

## 6. 移动端技术选型

1. 但对于制作移动端页面（主流）
    - 流式布局（百分比布局）
    - flex 弹性布局（强烈推荐）
    - less + rem + 媒体查询布局
    - 混合布局
  
2. 响应式页面兼容移动端
   - 媒体查询
   - bottstarp

## 6.1 流式布局（ep:京东 手机站）

- 流式布局局势百分比布局，也称非固定像素布局（宽以百分比设置）
- 通过合资的宽度设置成百分比来根据屏幕宽度进行伸缩，不受固定像素的限制，内容向两侧填充
- 流式布局时移动web开发使用的比较常见的布局方式
- max-width 最大宽度（max-height 最大高度）
- min-width 最小宽度（min-height 最小高度）

## 6.2 flex布局（ep：携程 手机站）

- 操作方便，布局极为简单，移动端应用广泛
- PC端浏览器支持比较差
- IE 11 及以下版本，不支持或仅部分支持

建议：
1. 如果是PC端页面布局，推荐还是传统布局
2. 如果是移动端或不考虑兼容性问题的PC端布局，我们还是使用 felx布局


### 6.2.1 felx布局原理

fle想是flexible box 的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局

- 当我们为父元素设为 flex 布局后， 子元素的 float 、clear 和 vertical-align 属性将失效
- 伸缩布局 = 弹性布局 = 伸缩和布局 = 弹性和布局 = flex布局

采用 felx 布局的元素，称之为 flex 容器，它的所有子元素自动成为容器成员，成为 flex 项目，简称项目。

总结： 就是通过给父盒子添加flex 属性，来控制 子盒子的位置和排列方式

### 6.2.2  常见父项属性

以下 6 个属性是对父元素设置的:
1. flex-direction: 设置主轴方向，控制子元素排列的方向
2. justify-content:设置主轴上子元素排列方式
3. flex-wrap:设置子元素是否换行
4. align-items: 设置侧轴上子元素的排列方式（单行）
5. align-content： 设置侧轴上子元素的排列方式（多行）
6. flex-flow:复合属性，相当于同时设置了 flex-direction 和 flex-wrap


flex-direction(重要):决定主轴的方向，确定完主轴方向后，剩下的就是侧轴，而我们的子元素就是根据主轴来排列的

| 属性值        | 说明           |
| ------------- | -------------- |
| row           | 默认值从左到右 |
| row-revese    | 从右到左       |
| column        | 从上到下       |
| column-revese | 从下到上       |


justify-content(注意主轴设置):

| 属性值        | 说明                                          |
| ------------- | --------------------------------------------- |
| flex-start    | 默认值从头部开始，如果主轴是x周，则从左道友   |
| flex-end      | 从尾部开始排列                                |
| center        | 在主轴居中对齐（乳沟是主轴是x轴，则水平居中） |
| space-around  | 平分剩余空间                                  |
| space-between | 先两边贴边，在平分剩余空间                    |

flex-wrap:默认情况下，项目（子元素）都排在一条线（又称“轴线”）上，flex 布局中默认是不换行的，如果排列补下子元素，会缩小子元素的宽度，可以通过设置flex-wrap换行。

| 属性值 | 说明           |
| ------ | -------------- |
| nowrap | 默认值，不换行 |
| wrap   | 换行           |

align-items：改属性控制子项在侧轴（默认 y 轴）上的排列方式（单行）

| 属性值     | 说明                     |
| ---------- | ------------------------ |
| flex-start | 从上到下                 |
| flex-end   | 从下岛上                 |
| center     | 挤在一起居中（垂直居中） |
| stretch    | 拉伸（默认值）           |

stretch，在子元素没给高度的情况下，默认拉伸子元素高度和父元素一样


align-content: 设置侧轴上的子元素的排列方式（多行）


| 属性值        | 说明                             |
| ------------- | -------------------------------- |
| flex-start    | 默认值，从侧轴的头部开始排列     |
| flex-end      | 从侧轴的尾部开始                 |
| center        | 侧轴居中显示                     |
| space-around  | 子项在侧轴平分剩余空间           |
| space-between | 子项先分布在两头，再平分剩余空间 |
| stretch       | 设置子项元素高度平分父元素高度   |

flex-flow: 是 flex-direction 和 flex-wrap 的合写。

```
flex-flow: column wrap;
```

### 6.2.3 flex布局中子项常见属性

- flex子项目占的分数
- align-self控制子项自己在侧轴的排列方式
- order 书香定义子项的排列顺序（前后顺序）


####  flex 属性定义子项目分配剩余空间，用 flex 表示所占多少份数

```
.item{
    flex: <number>; // 默认：0
}
```

#### align-self 控制子项自己在侧轴上的排列方式

align-self 属性允许单个项目有与其他项目不一样的对齐方式，可以覆盖 align-items属性
默认值为 auto， 表示继承父元素的align-items属性，如果没有父元素则等同于 stretch

```
span:nth-child(2){
    align-self:flex-end;
}
```

#### order 属性定义项目的排列顺序

数值越小，排列靠前，默认为0，

## 6.3 移动Web开发值 rem 适配

### 6.3.1 rem基础


rem（root em）单位是一个相对单位，类似于en， em是父元素字体大小，不同的是rem的基准是相对于html标签的字体大小。
比如，根元素（html）设置`font-size=12px`; 非根元素设置width:2rem; 则换算成px就是24px;

```
<style>
html {
    font-size:12px;
}

.div {

    width: 10rem; // 相当于是120px;
}
</style>
```

与单位 em 的区别：

- em 是相对于父元素的字体大小来说的
- rem 是相对于 html 元素设置的字体大小来说的

使用 rem 可以通过修改html里面的文字大小，来改变页面中元素的大小，可以实现整体控制

### 6.3.2 媒体查询

媒体查询是 CSS3 的新语法

- 使用@media查询，可以针对不同的媒体类型定义不同的样式
- **@media 可以针对不同的屏幕尺寸设置不同的样式**
- 当你充值浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面
- 目前真多很多 苹果、android 手机、平板等设备都用得到 媒体查询

语法

```
@media mediatype and|not|only (media feature) {
    css-code;
}
```

- 使用@media开头，注意@符号
- mediatype 媒体类型
- 关键字 and not only
- media feature 媒体特性必须小括号包含



mediatype 媒体类型，将不同终端设备划分为不同的类型

| 值     | 说明                               |
| ------ | ---------------------------------- |
| all    | 用于所有设备                       |
| print  | 用于打印机和打印预览               |
| screen | 用于电脑屏幕、平板电脑、智能手机等 |

 关键字，将媒体类型或多个媒体特性连接到一起作为媒体查询的查询条件
 
 - and：可以将多个媒体特性连接到一起，相当于且的意思
 - not：排除某个媒体类型，相当与非的意思，可以省略
 - only： 指定某个特定的媒体类型，可以省略

media feature(媒体特性):每种媒体都具有各自的特性，根据不同媒体类型的媒体特性设置不同的展示风格，我们暂且了解3个，注意要加小括号包含

| 值        | 说明                                 |
| --------- | ------------------------------------ |
| width     | 定义输出设备中页面可见区域的宽度     |
| min-width | 定义输出设备中页面最小可见区域的宽度 |
| max-width | 定义输出设备中页面最大可见区域的宽度 |


```
// 屏幕小于等于800px的时候 body 背景色设置为 pink
@media screen and （max-width:800px） {
    body {
        background-color:pink;
    }
}
```

媒体查询可以根据不同的屏幕尺寸改变不同的样式。

#### 引入资源


当样式比较繁多的时候，我们可以针对冉的媒体使用不同的stylesheets(样式表)，原理就是直接在link中判断设备的尺寸，然后引用不同的 css 文件。

```
<link rel="stylesheet" media="mediatype and|not|only (media featture)" href="url路径">
```

## 6.4 Less 

### 6.4.1 Less 基础

CSS 的弊端： CSS 是一门非程序式语言，没有变量、函数、作用域等概念

- CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度比较高
- 不方便维护及复用
- CSS没有很好的计算能力
- 非前端开发工程师来讲，往往缺乏CSS编写经验很难写出组织良好且易于维护的 CSS 代码项目

### 6.4.2 Less 介绍

Less （Leaner style sheets 的缩写）是一门 CSS 扩展语言，也称为 CSS 预处理器
作为 CSS 的一种形式扩展，他并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入传给你续语言的特性。

它在 CSS 的语法基础上，引入了 变量 Mixin(混入)、运算及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本。 官网 https://lesscss.cn

常见的 CSS 预处理器： Sass Less stylus。

 ### 6.4.3 Less 使用

首先需要创建 .less 文件。

 - Less 变量
 - Less 编译
 - Less 嵌套
 - Less 运算

#### Less 变量

变量是指没有固定的值，可以改变的。因为我们 CSS 中的一些颜色和数值等经常使用

```
@变量名： 值;
```

命名规范：

- 必须是@为前缀
- 不能包含特殊字符
- 不能以数字开头
- 大小写敏感

```
// my.less 文件
@color:pink;

body {
    background-color: @color;
}

div {
    color: @color;
}
```

### 6.4.5 Less 编译

本质上， Less 包含一套自定义的语法及一个解析器，用户滚局这些语法自定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。所以我们需要把我们写的 Less 文件编译生成 CSS 文件后倒入 HTML 文件中使用。

通过 vscode 的插件 `EasyLess`, ctrl + s 保存后，就会自动生成 css 文件。

### 6.4.6 Less 嵌套

1. less 嵌套，子元素直接卸载父元素里面
```
.header {
    width:200px;
    height:200px;
    background-color: pink;
    // 嵌套 a 标签
    a {
        background-color:red;
    }
}
```

2. 如果有伪类选择器、交集选择器、伪元素选择器我们内层选择器前面需要使用 & 开头，注意如果没有 &符号，会默认解析为父选择器的后代。

```
a {
    color: pink;
    &:hover {
        color:blue;
    }
}
```

### 6.4.7 Less 运算

任何数字、颜色或者变量都可以参与运算，Less 提供了基本的 + 、- 、* 、/ 运算。

- **运算符中间以空格隔开**
- 两个参数参与运算，如果有一个有单位，则最后的结果以这个单位为准
- 两个数参与运算，如果两个都有单位，且单位不一样，结果以第一个单位为准

## 6.5 rem适配方案

1. 让一些不能等比字是一个的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备
2. 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配


rem适配：我们首先学习 rem 的原理，知道rem（root em）单，rem 是根据 `html` 元素的`font-size`属性来控制大小，然后到媒体查询，知道可以动态改变（根据@media） HTML 标签的`font-size`大小。最后因为 CSS 不支持运算，而我们 rem 需要大量的计算功能，所以又学习使用 `Less` 更快的书写 CSS 代码。

### 6.5.1 rem 实际开发适配方案

1. 按照设计稿与设备宽度的比例，动态计算并设置 html 跟标签的 font-size 大小
2. CSS中， 设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 单位的值


### 6.5.2 rem 适配方案技术使用（市场）

方案一： 
 - less
 - 媒体查询
 - rem

方案二(推荐、更简单)：
 - flexible.js
 - rem

### 6.5.3 实际开发适配方案

开发的步骤：

1. 首先选一套标准的尺寸设计稿，如以 750px 为准
2. 我们用屏幕尺寸 除以 我们划分的份数，得到了 html 里 font-size 的大小（不同屏幕下，我们可以通过媒体查询（@media）来设置不一样的大小）
3. 页面元素的rem值= 页面元素在 750 px下的像素值（px）/ html里font-size的大小

### 6.6 响应式布局——bottstarp

#### 6.6.1 响应式开发原理

就是使用媒体查询针对不同宽度的设备进行布局和样式设置，从而适配不同设备的目的。


| 设备划分                 | 尺寸区间            |
| ------------------------ | ------------------- |
| 超小屏(手机)             | < 768px             |
| 小屏设备（平板）         | >= 768px ~ < 992px  |
| 中等屏幕（桌面显示器）   | >= 992px ~ < 1200px |
| 宽屏设备（大桌面显示器） | > 1200px            |

#### 6.6.2 响应式布局容器

响应式需要一个父级作为布局容器，来配合子级元素来实现变化效果。

原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，在改变里面子元素的布局排列的方式和大小，从而实现在不同屏幕下，看到不同的布局和样式变化。

平时我们的响应式尺寸划分：

- 超小屏（手机，小于768px）:设置为宽度100%
- 小屏幕（平板， >= 768px）：设置为宽度为750px
- 中等屏幕（桌面显示器，大于992px）：宽度设置为970px
- 宽屏设备（大桌面显示器，大于1200px）：宽度设置为 1170px

以上划分只是参考，实际开发以实际为准。宽度设置一般比屏幕宽度稍小，两边留白，美观。

## 7. Bootstrap 前端开发框架

### 7.1 Bootstrap 简介

Bootstrap 来自 Twitter ，是目前最受欢迎的前端框架，Bootstrap 是基于 HTML CSS 和 JavaScript的，它简介灵活，使得 Web开发更加快捷。

优点
- 标注啊饿html+css编码规范
- 提供一套简洁、直观、强悍的组件
- 有自己的生态圈，不断的更新迭代
- 让开发更简单，提高开发效率

### 7.2 Bootstrap 使用

在现阶段没有接触JS相关教程，所以只考虑它的样式库。

**控制权在框架本身，使用者要按照框架规定的某种规范开发**

Bootstrap 使用四部曲：
1. 创建文件夹结构
2. 创建htnl骨架结构
3. 引入相关样式文件
4. 书写内容

书写内容时可以有以下操作：

- 直接拿Bootstrap 预先定义好的样式使用
- 修改 Bootstrap 原来的样式，注意权重问题
- 学号 Bootstrap 的关键在于知道，它定义了那些样式，以及这些样式能实现什么样的效果


### 7.3 布局容器

Bootstrap 需要为页面内容和栅格系统包裹一个容器类， Bootstrap 预先定义好了两个类，分别是 .container类 、 .container-fluid类

1. .container 类
   - 响应式布局的容器 固定宽度
   - 大屏（>=1200px）宽度定位 1170px
   - 中屏（>=992px）宽度定位 1170px
   - 小屏（>=768px）宽度定位 1170px
   - 超小屏：100%
   - 
2. .container-fluid 类
   - 流式布局容器， 百分比宽度
   - 占据全部视口的容器
   - 适合与单独做移动端开发

### 7.4 Bootstrap 栅格系统 

#### 栅格系统简介

栅格系统英文为“grid system”，也有人成为网格系统，它是指将页面划分为等宽的列，然后通过列数的定义来模块化页面布局

Bootstrap 提供了一套响应式、移动设备有限的流式栅格系统，随着屏幕或视口尺寸的增加，系统会自动分为最多12 列。

Bootstrap里面的container宽度是固定的，但是在不同屏幕下，container的宽度不同，我们在把container划分为12等分。

#### 栅格选项参数

栅格系统用于通过一系列的行（row）和列（column）的组合来创建页面布局，你的内容可以放入这些创建好的布局中。

- 行必须放在 container 布局容器里面
- 我们实现列的平均划分，需要给列添加类前缀
- xs（extra small）:超小; sm（small）:小;md（medium）:中等;lg（lager）:大;
- 列大于12，多余的列所在的元素将被看作一个整体另起一行排列
- 每一列默认左右都有15px的padding
- 可以同时为一列指定多个设备的类名，以便花费不同分数。如：`class=col-md-4 col-sm-6;`


### 7.5 列嵌套

栅格系统内置的栅格系统将内容再次嵌套，简单的理解就是一个列内在被分成若干份小列，我们可以通过添加一个新的 .row 元素和一系列 `.col-sm-*` 元素到已经存在的 `.col-sm-*` 元素内

列嵌套的时候最好新增一个 行元素（.row）这样可以取消父元素的padding 而且和父元素高度一致、

```
// 列嵌套
<div class="container">
    <div class="row">
        <div class="col-md-4">
            <div class="row">
                <div class="col-md-6">a</div>
                <div class="col-md-6">b</div>
            </div>
        </div>
        <div class="col-md-4">2</div>
        <div class="col-md-4">3</div>
    </div>
</div>
```

### 7.6 列偏移

使用 `.col-md-offse-*` 类可以将列向右偏移，这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距。

```
<div class="container">
    <div class="row">
                <div class="col-md-4">a</div>
                <div class="col-md-4 col-md-offse-4">b</div>
    </div>
</div>
```

### 7.7 列排序

使用 `.col-md-push-*` 和 `.col-md-pull` 类就很容易改变列（column）的顺序。

如下，左侧和右侧两个盒子顺序更换：
```
<div class="container">
    <div class="row">
        <div class="col-md-4 col-md-push-8">左侧</div>
        <div class="col-md-8 col-md-pull-4">右侧</div>
    </div>
</div>
```

### 7.8 响应式工具

为了加快对移动设备友好的页面工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。


| 类名       | 超小屏 | 小屏 | 中屏 | 大屏 |
| ---------- | ------ | ---- | ---- | ---- |
| .hidden-xs | 隐藏   | 可见 | 可见 | 可见 |
| .hidden-sm | 可见   | 隐藏 | 可见 | 可见 |
| .hidden-md | 可见   | 可见 | 隐藏 | 可见 |
| .hidden-lg | 可见   | 可见 | 可见 | 隐藏 |

与之相反的，`visible-xs`、`visible-sm`、`visible-md`、`visible-lg`是显示某个页面的内容。


## 8 移动端布局——vw和vh

- vw/vh 是一个相对单位（类似em 和 rem 相对单位）
    - vw是： viewport width 视口宽度单位
    - vh是： viewport height 视口高度单位

- 相对视口的尺寸计算结果
    - 1vw = 1/100 视口宽度
    - 1vh = 1/100 视口高度
如当前屏幕视口是 375 像素，则 1 vw 就是 3.75 像素，如果当前屏幕视口是 414 则 1vw 是4.14 像素

注： 和百分比的区别在于 百分比是相对父元素来说的，vw 、vh 总是针对于当前视口的